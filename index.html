<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>AVC vs Modern Codec Bandwidth Demo (1080p)</title>
    <style>
      :root {
        color-scheme: light dark;
        --bg: #0b1220;
        --card: rgba(255, 255, 255, 0.06);
        --text: rgba(255, 255, 255, 0.92);
        --muted: rgba(255, 255, 255, 0.7);
        --border: rgba(255, 255, 255, 0.12);
        --accent: #7dd3fc;
      }
      @media (prefers-color-scheme: light) {
        :root {
          --bg: #f6f7fb;
          --card: rgba(0, 0, 0, 0.04);
          --text: rgba(0, 0, 0, 0.9);
          --muted: rgba(0, 0, 0, 0.65);
          --border: rgba(0, 0, 0, 0.12);
          --accent: #0369a1;
        }
      }
      body {
        margin: 0;
        font-family:
          ui-sans-serif,
          system-ui,
          -apple-system,
          Segoe UI,
          Roboto,
          Helvetica,
          Arial,
          "Apple Color Emoji",
          "Segoe UI Emoji";
        background: radial-gradient(1200px 600px at 25% 0%, rgba(125, 211, 252, 0.18), transparent 60%),
          radial-gradient(900px 500px at 90% 10%, rgba(167, 139, 250, 0.16), transparent 55%),
          var(--bg);
        color: var(--text);
      }
      .wrap {
        max-width: 1200px;
        margin: 0 auto;
        padding: 28px 18px 46px;
      }
      header {
        display: flex;
        flex-direction: column;
        gap: 10px;
        margin-bottom: 18px;
      }
      h1 {
        font-size: 20px;
        margin: 0;
        letter-spacing: 0.2px;
      }
      .sub {
        margin: 0;
        color: var(--muted);
        line-height: 1.45;
      }
      .controls {
        margin-top: 10px;
        display: grid;
        grid-template-columns: 1fr auto auto;
        gap: 10px;
        align-items: center;
      }
      input[type="url"],
      input[type="number"] {
        width: 100%;
        padding: 10px 12px;
        border-radius: 10px;
        border: 1px solid var(--border);
        background: rgba(0, 0, 0, 0.12);
        color: var(--text);
        outline: none;
      }
      .coverage-control {
        margin-top: 10px;
        display: flex;
        align-items: center;
        gap: 10px;
      }
      .coverage-control label {
        font-size: 14px;
        color: var(--muted);
      }
      .coverage-control input[type="number"] {
        width: 80px;
        text-align: center;
      }
      .coverage-control span {
        color: var(--muted);
        font-size: 14px;
      }
      button {
        padding: 10px 12px;
        border-radius: 10px;
        border: 1px solid var(--border);
        background: rgba(255, 255, 255, 0.06);
        color: var(--text);
        cursor: pointer;
      }
      button:hover {
        border-color: rgba(125, 211, 252, 0.5);
      }
      .grid {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 14px;
        margin-top: 14px;
      }
      @media (max-width: 980px) {
        .grid {
          grid-template-columns: 1fr;
        }
      }
      .card {
        background: var(--card);
        border: 1px solid var(--border);
        border-radius: 16px;
        padding: 12px;
        backdrop-filter: blur(12px);
      }
      .card h2 {
        margin: 0 0 8px;
        font-size: 14px;
        font-weight: 650;
        letter-spacing: 0.2px;
        display: flex;
        align-items: baseline;
        justify-content: space-between;
        gap: 12px;
      }
      .pill {
        font-size: 12px;
        color: var(--muted);
        border: 1px solid var(--border);
        border-radius: 999px;
        padding: 4px 8px;
        white-space: nowrap;
      }
      video {
        width: 100%;
        aspect-ratio: 16 / 9;
        background: #000;
        border-radius: 12px;
      }
      .stats {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 10px;
        margin-top: 10px;
      }
      .stat {
        border: 1px solid var(--border);
        border-radius: 12px;
        padding: 10px 10px;
        background: rgba(0, 0, 0, 0.08);
      }
      .stat .k {
        font-size: 12px;
        color: var(--muted);
        margin: 0 0 4px;
      }
      .stat .v {
        font-variant-numeric: tabular-nums;
        font-size: 18px;
        margin: 0;
      }
      .footer {
        margin-top: 12px;
        color: var(--muted);
        font-size: 12px;
        line-height: 1.45;
      }
      .footer code {
        color: var(--text);
      }
      .overall {
        margin-top: 14px;
        display: grid;
        grid-template-columns: 1fr 1fr 1fr;
        gap: 10px;
      }
      @media (max-width: 980px) {
        .overall {
          grid-template-columns: 1fr;
        }
      }
      .savings-tracking {
        margin-top: 14px;
      }
      .tracking-stats {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 10px;
      }
      @media (max-width: 980px) {
        .tracking-stats {
          grid-template-columns: 1fr;
        }
      }
      .tracking-stat {
        border: 1px solid var(--border);
        border-radius: 12px;
        padding: 10px;
        background: rgba(0, 0, 0, 0.08);
      }
      .clear-btn {
        padding: 4px 8px;
        font-size: 12px;
        border-radius: 6px;
        border: 1px solid var(--border);
        background: rgba(255, 255, 255, 0.06);
        color: var(--text);
        cursor: pointer;
      }
      .clear-btn:hover {
        border-color: rgba(255, 100, 100, 0.6);
        background: rgba(255, 100, 100, 0.1);
      }
      .note {
        margin-top: 10px;
        border-left: 3px solid rgba(125, 211, 252, 0.6);
        padding: 10px 12px;
        border-radius: 10px;
        background: rgba(125, 211, 252, 0.08);
        color: var(--muted);
      }
      .note b {
        color: var(--text);
      }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/shaka-player/4.10.4/shaka-player.compiled.js"></script>
  </head>
  <body>
    <div class="wrap">
      <header>
        <h1>AVC vs Modern Codec Bandwidth Demo (1080p)</h1>
        <p class="sub">
          This page loads the <b>same stream twice</b> and forces each player to prefer a different codec, then shows the
          <b>total bandwidth consumed (MB)</b> per player and combined.
        </p>
        <div class="controls">
          <input id="manifestUrl" type="url" spellcheck="false" placeholder="Paste DASH (.mpd) or HLS (.m3u8) URL here" />
          <button id="loadBtn">Load</button>
          <button id="resetBtn" title="Resets counters (does not clear browser cache)">Reset Counters</button>
        </div>
        <div class="coverage-control">
          <label for="coverageInput">Device Coverage (<span id="coverageCodecName">HEVC</span>-capable):</label>
          <input id="coverageInput" type="number" min="0" max="100" value="33" step="1" />
          <span>%</span>
        </div>
      </header>

      <section class="overall">
        <div class="stat card">
          <p class="k">Savings (<span id="savingsCodecName">HEVC</span> vs AVC)</p>
          <p class="v" id="savingsMb">0.00 MB</p>
        </div>
        <div class="stat card">
          <p class="k">Savings %</p>
          <p class="v" id="savingsPct">0.0%</p>
        </div>
        <div class="stat card">
          <p class="k">Savings at <span id="coverageDisplay">33</span>% coverage</p>
          <p class="v" id="savingsAtCoverageMb">0.00 MB</p>
        </div>
      </section>

      <section class="savings-tracking">
        <div class="card">
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
            <h3 style="margin: 0; font-size: 14px; font-weight: 650;">Savings Tracking</h3>
          </div>
          <div class="tracking-stats">
            <div class="tracking-stat">
              <div style="display: flex; justify-content: space-between; align-items: center;">
                <span class="k">This Session</span>
                <button id="clearSessionBtn" class="clear-btn" title="Clear this session's savings">Clear</button>
              </div>
              <p class="v" id="sessionSavingsMb">0.00 MB</p>
            </div>
            <div class="tracking-stat">
              <div style="display: flex; justify-content: space-between; align-items: center;">
                <span class="k">All Sessions (at <span id="allSessionsCoverageDisplay">33</span>% coverage)</span>
                <button id="clearAllBtn" class="clear-btn" title="Clear all accumulated savings">Clear</button>
              </div>
              <p class="v" id="allSessionsSavingsMb">0.00 MB</p>
            </div>
          </div>
        </div>
      </section>

      <section class="grid">
        <div class="card">
          <h2>
            AVC Player <span class="pill">Prefer codecs: <code>avc1</code></span>
          </h2>
          <video id="videoAvc" controls muted playsinline autoplay></video>
          <div class="stats">
            <div class="stat">
              <p class="k">Downloaded</p>
              <p class="v" id="avcMb">0.00 MB</p>
            </div>
            <div class="stat">
              <p class="k">Selected Variant</p>
              <p class="v" id="avcVariant">—</p>
            </div>
          </div>
        </div>

        <div class="card">
          <h2>
            <span id="modernCodecName">HEVC</span> Player <span class="pill" id="modernCodecPill">Prefer codecs: <code>hvc1</code>/<code>hev1</code></span>
          </h2>
          <video id="videoModern" controls muted playsinline autoplay></video>
          <div class="stats">
            <div class="stat">
              <p class="k">Downloaded</p>
              <p class="v" id="modernMb">0.00 MB</p>
            </div>
            <div class="stat">
              <p class="k">Selected Variant</p>
              <p class="v" id="modernVariant">—</p>
            </div>
          </div>
        </div>
      </section>

      <div class="footer">
        Tips:
        <ul>
          <li>
            For best results, use a manifest that includes <b>both AVC and the selected modern codec (HEVC/AV1) 1080p</b> variants (same ladder). This
            demo will then show the byte savings clearly.
          </li>
          <li>
            Bandwidth is measured by summing the bytes of each segment response returned to the player (not an estimate).
          </li>
        </ul>
      </div>
    </div>

    <script>
      // Default stream (can be overridden via ?manifest=...).
      const DEFAULT_MANIFEST_URL =
        "https://renditions-cloudfront.jwpsrv.com/696e5371_8e460a16ca689acbf455ec64386ca807aed98a95/sites/TXXJgKqJ/media/BMlhWwAx/versions/QoHU0nMb/custom_manifest.ism/.m3u8";

      const el = (id) => document.getElementById(id);
      const fmtMb = (bytes) => `${(bytes / (1024 * 1024)).toFixed(2)} MB`;
      const fmtPct = (x) => `${(x * 100).toFixed(1)}%`;

      const CODEC_CONFIG = {
        hevc: {
          name: "HEVC",
          codecs: ["hvc1", "hev1"],
          pill: 'Prefer codecs: <code>hvc1</code>/<code>hev1</code>',
        },
        av1: {
          name: "AV1",
          codecs: ["av01"],
          pill: 'Prefer codecs: <code>av01</code>',
        },
      };

      let playerAvc, playerModern;
      let bytesAvc = 0;
      let bytesModern = 0;
      let currentCodec = "hevc"; // Will be auto-detected
      let sessionSavingsBytes = 0;
      
      function getAllSessionsSavings() {
        const stored = localStorage.getItem("allSessionsSavingsBytes");
        return stored ? parseFloat(stored) : 0;
      }
      
      function saveAllSessionsSavings(bytes) {
        localStorage.setItem("allSessionsSavingsBytes", bytes.toString());
      }

      function updateCodecLabels() {
        const config = CODEC_CONFIG[currentCodec];
        el("modernCodecName").textContent = config.name;
        el("modernCodecPill").innerHTML = config.pill;
        el("savingsCodecName").textContent = config.name;
        el("coverageCodecName").textContent = config.name;
      }

      function updateUi() {
        el("avcMb").textContent = fmtMb(bytesAvc);
        el("modernMb").textContent = fmtMb(bytesModern);

        const savings = Math.max(0, bytesAvc - bytesModern);
        el("savingsMb").textContent = fmtMb(savings);
        el("savingsPct").textContent = bytesAvc > 0 ? fmtPct(savings / bytesAvc) : "0.0%";

        const coverage = parseFloat(el("coverageInput").value) || 0;
        const coverageDecimal = Math.max(0, Math.min(100, coverage)) / 100;
        const savingsAtCoverage = savings * coverageDecimal;
        el("savingsAtCoverageMb").textContent = fmtMb(savingsAtCoverage);
        el("coverageDisplay").textContent = Math.round(coverage);
        
        // Update session savings (track maximum savings seen this session)
        if (savings > sessionSavingsBytes) {
          sessionSavingsBytes = savings;
        }
        el("sessionSavingsMb").textContent = fmtMb(sessionSavingsBytes);
        
        // Update all sessions savings (display total accumulated)
        const allSessionsBytes = getAllSessionsSavings();
        el("allSessionsSavingsMb").textContent = fmtMb(allSessionsBytes);
        el("allSessionsCoverageDisplay").textContent = Math.round(coverage);
      }

      function attachByteCounter(player, which) {
        const net = player.getNetworkingEngine();
        net.registerResponseFilter((type, response) => {
          // Sum bytes of manifest + segment responses that Shaka sees.
          const b = response && response.data ? response.data.byteLength : 0;
          if (!b) return;
          if (which === "avc") bytesAvc += b;
          else bytesModern += b;
          updateUi();
        });
      }

      function wireVariantUi(player, variantElId) {
        const render = () => {
          const tracks = player.getVariantTracks().filter((t) => t.active);
          const t = tracks[0];
          if (!t) return;
          const codec = t.videoCodec || "—";
          const res = t.height ? `${t.height}p` : "—";
          el(variantElId).textContent = `${res} · ${codec}`;
        };
        player.addEventListener("adaptation", render);
        player.addEventListener("trackschanged", render);
        player.addEventListener("variantchanged", render);
        setTimeout(render, 250);
      }

      function configurePlayers() {
        if (!playerAvc || !playerModern) return;

        // Prefer 1080p by capping max height (keeps the demo stable for sales).
        const baseCfg = {
          abr: { enabled: true },
          restrictions: { maxHeight: 1080 },
        };

        playerAvc.configure({
          ...baseCfg,
          preferredVideoCodecs: ["avc1"],
        });

        const config = CODEC_CONFIG[currentCodec];
        playerModern.configure({
          ...baseCfg,
          preferredVideoCodecs: config.codecs,
        });
      }

      async function initPlayers() {
        if (!shaka.Player.isBrowserSupported()) {
          alert("Shaka Player: browser not supported.");
          return;
        }

        const videoAvc = el("videoAvc");
        const videoModern = el("videoModern");

        playerAvc = new shaka.Player(videoAvc);
        playerModern = new shaka.Player(videoModern);

        attachByteCounter(playerAvc, "avc");
        attachByteCounter(playerModern, "modern");

        configurePlayers();

        wireVariantUi(playerAvc, "avcVariant");
        wireVariantUi(playerModern, "modernVariant");
      }

      async function detectCodec(url) {
        // Create a temporary player to detect available codecs
        const tempVideo = document.createElement("video");
        const tempPlayer = new shaka.Player(tempVideo);
        
        try {
          await tempPlayer.load(url);
          const tracks = tempPlayer.getVariantTracks();
          
          // Check for AV1 first (prefer newer codec)
          const hasAv1 = tracks.some(t => t.videoCodec && (t.videoCodec.includes("av01") || t.videoCodec.includes("av1")));
          if (hasAv1) {
            await tempPlayer.unload();
            return "av1";
          }
          
          // Check for HEVC
          const hasHevc = tracks.some(t => t.videoCodec && (t.videoCodec.includes("hvc1") || t.videoCodec.includes("hev1") || t.videoCodec.includes("hevc")));
          if (hasHevc) {
            await tempPlayer.unload();
            return "hevc";
          }
          
          await tempPlayer.unload();
          // Default to HEVC if neither found
          return "hevc";
        } catch (e) {
          try {
            await tempPlayer.unload();
          } catch {}
          // Default to HEVC on error
          return "hevc";
        }
      }

      async function loadManifest(url) {
        const u = (url || "").trim();
        if (!u) {
          alert("Please provide a manifest URL (DASH .mpd or HLS .m3u8).");
          return;
        }

        // Stop previous playback (if any) to keep counters stable.
        try {
          await playerAvc.unload();
          await playerModern.unload();
        } catch (e) {
          // ignore
        }

        // Auto-detect codec from manifest
        currentCodec = await detectCodec(u);
        updateCodecLabels();
        configurePlayers();
        await Promise.all([playerAvc.load(u), playerModern.load(u)]);
      }

      function resetCounters() {
        // Accumulate session savings to all sessions before resetting
        if (sessionSavingsBytes > 0) {
          const currentAll = getAllSessionsSavings();
          saveAllSessionsSavings(currentAll + sessionSavingsBytes);
        }
        bytesAvc = 0;
        bytesModern = 0;
        sessionSavingsBytes = 0;
        updateUi();
      }
      
      function clearSessionSavings() {
        sessionSavingsBytes = 0;
        updateUi();
      }
      
      function clearAllSessionsSavings() {
        saveAllSessionsSavings(0);
        updateUi();
      }

      (async function main() {
        await initPlayers();
        updateCodecLabels();

        const params = new URLSearchParams(location.search);
        const fromQs = params.get("manifest");
        const initial = fromQs || DEFAULT_MANIFEST_URL;

        el("manifestUrl").value = initial || "";
        updateUi();

        el("loadBtn").addEventListener("click", async () => loadManifest(el("manifestUrl").value));
        el("resetBtn").addEventListener("click", resetCounters);
        el("coverageInput").addEventListener("input", updateUi);
        el("clearSessionBtn").addEventListener("click", clearSessionSavings);
        el("clearAllBtn").addEventListener("click", clearAllSessionsSavings);

        if (initial) {
          await loadManifest(initial);
        }
      })();
    </script>
  </body>
</html>

